---
description: Phase 2: Session Discovery & Joining
globs:
alwaysApply: false
---

# Phase 2: Session Discovery & Joining

## Overview

Build session discovery functionality that allows users to find and join public sessions created by other users. This phase focuses on creating a browsable list of available sessions and implementing the join/leave functionality without advanced location or friend filtering.

## Goals

- Create session discovery interface
- Implement session joining/leaving functionality
- Add participant tracking system
- Build basic session filtering capabilities
- Prepare for location-based filtering in Phase 3

## Data Model Changes

### New Tables

#### Session Participants Table

```sql
CREATE TABLE session_participants (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  session_id UUID REFERENCES sessions(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  status TEXT DEFAULT 'joined' CHECK (status IN ('joined', 'left', 'waitlisted')),
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  left_at TIMESTAMP WITH TIME ZONE,
  UNIQUE(session_id, user_id)
);
```

#### User Profiles Table (Basic)

```sql
CREATE TABLE user_profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  username TEXT UNIQUE,
  display_name TEXT,
  dupr_rating DECIMAL(3,1),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Updated Interfaces

```typescript
interface SessionParticipant {
  id: string;
  session_id: string;
  user_id: string;
  status: "joined" | "left" | "waitlisted";
  joined_at: string;
  left_at?: string;
  user_profile?: UserProfile;
}

interface SessionWithParticipants extends EnhancedSession {
  participants: SessionParticipant[];
  current_participants: number;
  is_full: boolean;
  user_status?: "joined" | "left" | "waitlisted" | "not_joined";
}
```

## UI/UX Changes

### New Screens

#### Session Discovery Screen

- **Location**: `app/(tabs)/sessions/browse.tsx`
- **Purpose**: Browse and filter public sessions
- **Features**:
  - List of public sessions
  - Basic filtering (date, DUPR range, availability)
  - Session cards with participant count
  - Join/Leave buttons
  - Waitlist functionality

#### Session Detail Screen

- **Location**: `app/(tabs)/sessions/[sessionId].tsx`
- **Purpose**: Detailed view of a specific session
- **Features**:
  - Full session information
  - Participant list
  - Join/Leave/Waitlist actions
  - Session creator information

### Enhanced Sessions Tab

- **Current**: Simple list of user's sessions
- **Enhanced**: Tab-based navigation
  - "My Sessions" - User's created sessions
  - "Browse" - Public session discovery
  - "Joined" - Sessions user has joined

### Session Discovery Components

**New Components:**

- `SessionDiscoveryList` - Main list of browsable sessions
- `SessionCard` - Individual session display with join/leave actions
- `SessionFilters` - Date, DUPR, and availability filters
- `ParticipantsList` - Display session participants
- `JoinSessionButton` - Join/Leave/Waitlist action button
- `SessionAvailabilityBadge` - Show spots available/full/waitlist

## Service Layer Updates

### Enhanced Session Service

```typescript
interface SessionService {
  // Phase 1 methods remain unchanged

  // Phase 2 additions
  discoverSessions: (
    filters: SessionFilters
  ) => Promise<SessionWithParticipants[]>;
  getSessionById: (sessionId: string) => Promise<SessionWithParticipants>;
  joinSession: (sessionId: string) => Promise<SessionParticipant>;
  leaveSession: (sessionId: string) => Promise<void>;
  getSessionParticipants: (sessionId: string) => Promise<SessionParticipant[]>;
  getUserJoinedSessions: () => Promise<SessionWithParticipants[]>;
}

interface SessionFilters {
  date?: string;
  dupr_min?: number;
  dupr_max?: number;
  availability?: "available" | "full" | "all";
  session_type?: string;
}
```

### User Profile Service

```typescript
interface UserProfileService {
  getProfile: (userId?: string) => Promise<UserProfile>;
  updateProfile: (updates: Partial<UserProfile>) => Promise<UserProfile>;
  createProfile: (profileData: UserProfileCreate) => Promise<UserProfile>;
}
```

## Architecture Changes

### Component Structure

```
components/
├── sessions/
│   ├── discovery/
│   │   ├── SessionDiscoveryList.tsx
│   │   ├── SessionCard.tsx
│   │   ├── SessionFilters.tsx
│   │   ├── JoinSessionButton.tsx
│   │   └── SessionAvailabilityBadge.tsx
│   ├── detail/
│   │   ├── SessionDetail.tsx
│   │   ├── ParticipantsList.tsx
│   │   └── SessionActions.tsx
│   └── navigation/
│       └── SessionsTabs.tsx
```

### State Management

**Enhanced Session Context:**

```typescript
interface SessionContextType {
  // Phase 1 state remains

  // Phase 2 additions
  publicSessions: SessionWithParticipants[];
  joinedSessions: SessionWithParticipants[];
  sessionFilters: SessionFilters;

  // Phase 2 actions
  discoverSessions: (filters: SessionFilters) => Promise<void>;
  joinSession: (sessionId: string) => Promise<void>;
  leaveSession: (sessionId: string) => Promise<void>;
  refreshJoinedSessions: () => Promise<void>;
  updateFilters: (filters: Partial<SessionFilters>) => void;
}
```

## Security Considerations

### Row Level Security (RLS)

#### Session Participants Policies

```sql
-- Users can view participants of public sessions or sessions they're in
CREATE POLICY "Users can view session participants" ON session_participants
  FOR SELECT USING (
    session_id IN (
      SELECT id FROM sessions WHERE
      visibility = 'public' OR
      auth.uid() = user_id OR
      auth.uid() IN (
        SELECT user_id FROM session_participants sp2
        WHERE sp2.session_id = session_participants.session_id
      )
    )
  );

-- Users can join public sessions
CREATE POLICY "Users can join sessions" ON session_participants
  FOR INSERT WITH CHECK (
    auth.uid() = user_id AND
    session_id IN (
      SELECT id FROM sessions WHERE visibility = 'public'
    )
  );

-- Users can update their own participation status
CREATE POLICY "Users can update their participation" ON session_participants
  FOR UPDATE USING (auth.uid() = user_id);
```

#### User Profiles Policies

```sql
-- Users can view all profiles (for participant lists)
CREATE POLICY "Users can view profiles" ON user_profiles
  FOR SELECT USING (true);

-- Users can only update their own profile
CREATE POLICY "Users can update own profile" ON user_profiles
  FOR UPDATE USING (auth.uid() = id);
```

## Business Logic

### Session Joining Rules

1. **Availability Check**: Session must have available spots
2. **DUPR Matching**: User's DUPR must fall within session range (if specified)
3. **Status Validation**: Session must be in 'scheduled' status
4. **Duplicate Prevention**: User cannot join same session twice

### Waitlist System

1. **Auto-Waitlist**: Users join waitlist when session is full
2. **Promotion**: First waitlisted user gets spot when someone leaves
3. **Notification**: Users notified when promoted from waitlist (Phase 4)

## Performance Considerations

### Database Optimization

#### Indexes

```sql
-- Session discovery queries
CREATE INDEX idx_sessions_visibility_date ON sessions (visibility, date) WHERE visibility = 'public';
CREATE INDEX idx_sessions_dupr_range ON sessions (dupr_min, dupr_max) WHERE dupr_min IS NOT NULL;

-- Participant queries
CREATE INDEX idx_session_participants_session_id ON session_participants (session_id);
CREATE INDEX idx_session_participants_user_id ON session_participants (user_id);
CREATE INDEX idx_session_participants_status ON session_participants (status);
```

#### Query Optimization

- Use joins to get participant counts in single query
- Implement pagination for session discovery
- Cache frequently accessed session data

### Frontend Optimization

- Implement virtual scrolling for large session lists
- Use optimistic updates for join/leave actions
- Cache session data with appropriate TTL

## Testing Strategy

### Unit Tests

- Session joining/leaving logic
- Participant count calculations
- Session filtering functionality
- RLS policy enforcement

### Integration Tests

- End-to-end session discovery flow
- Join/leave session workflows
- Waitlist promotion logic
- Cross-user session visibility

## Rollout Strategy

### Phase 2.1: Data Model

- Deploy new tables and indexes
- Migrate existing session creators as participants
- Test participant tracking system

### Phase 2.2: Session Discovery

- Deploy session browsing interface
- Implement basic filtering
- Monitor discovery usage patterns

### Phase 2.3: Join/Leave Functionality

- Deploy join/leave actions
- Implement waitlist system
- Monitor participation metrics

## Success Metrics

### Engagement Metrics

- Session discovery usage rate
- Join/leave action frequency
- Session fill rate (participants vs max_players)
- Waitlist conversion rate

### Technical Metrics

- Session discovery query performance
- Join/leave action success rate
- Database query efficiency
- User session participation patterns

## Future Considerations

### Phase 3 Preparation

- Session data ready for location-based filtering
- UI components prepared for location integration
- Service layer ready for geospatial queries

### Scalability

- Efficient session discovery patterns
- Participant tracking optimization
- Prepared for real-time updates

## Risk Assessment

### Technical Risks

- **Performance**: Large session lists may impact load times
- **Concurrency**: Multiple users joining same session simultaneously
- **Data Consistency**: Participant counts vs actual participants

### Mitigation Strategies

- **Performance**: Implement pagination and caching
- **Concurrency**: Use database constraints and optimistic locking
- **Consistency**: Use database triggers for count maintenance

## Implementation Priority

### High Priority

1. Session participants table and RLS
2. Session discovery interface
3. Join/leave functionality

### Medium Priority

1. Session filtering system
2. Waitlist functionality
3. Participant count optimization

### Low Priority

1. Advanced session sorting
2. Session discovery analytics
3. Performance monitoring tools

This phase establishes the core social functionality of finding and joining sessions, creating the foundation for location-based filtering and invitation systems in subsequent phases.

---
